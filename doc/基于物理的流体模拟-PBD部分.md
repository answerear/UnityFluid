# 基于物理的流体模拟-PBD部分

## 基于位置动力学（Position Based Dynamics）

### 基于力的动力学

前面介绍了流体力学方面的知识。可以看出传统的物理求解方法，都是基于力来求解的，一般流程是：

1. 计算内力。如流体的粘滞力（Viscosity）、压力（Pressure）等
2. 计算外力。如重力（Gravity）、碰撞力（Collision）、风力（Wind）等
3. 把内力和外力合在一起，根据经典力学牛顿第二定律 $\vec{F}=m\vec{a}$ ，求出加速度
4. 通过数值计算方法，计算速度 $\vec{v}=\vec{a}t$ 
5. 通过数值计算方法，计算位置 $\vec{x}^* = \vec{x}_0 + \vec{v}t$ 

虽然基于上述的计算符合物理规则，但是我们做计算机工程，这种方法在计算机中，特别是实时游戏应用中是否适用呢？我们接下来看看具体情况。

### 基于力的动力学的缺陷

计算物体间的碰撞是物理引擎最核心的部分。如右图，一般来说，先要解决如何高效的检测到碰撞的产生（碰撞检测），以及如何确定碰撞点及方向，之后我们就可以求得碰撞体的受力情况，从而根据牛顿运动定律计算出它们将要产生的平动和转动。最后将场景中物体的位置和姿态输出给图形引擎去渲染。

如何求得力和力矩，这是一个很复杂的问题。

像重力可以直接影响物体所受力，摩擦可以直接影响物体所受力矩，这些都很简单，较为复杂的就是两个物体间的碰撞，物理引擎中有一半以上的代码是用来计算碰撞的。

下面我们来看一个碰撞例子。

由于碰撞时间极短，通常只有千分之一秒甚至万分之一秒，因此所产生的力非常巨大。这种产生在碰撞中，作用时间极短，数值巨大的力称为碰撞力瞬时力。瞬时力的冲量称之为碰撞冲量。瞬时力不仅数值巨大，而且随时间迅速变化，其规律非常复杂，难以确定。碰撞过程中除了由碰撞力引起物体塑性变形外，同时还伴随着发声、发光和发热等机械能转换为其他形式能量的现象。由于碰撞时间很短，发生在瞬时，需要很小的时间步长去计算碰撞力，在实际计算机应用中，特别是实时性要求很强的游戏应用中，如果时间步长分得太多，会有明显的卡顿感，这个严重影响游戏体验。所以我们需要考虑另外的方案来实现游戏中的物理模拟。

### 基于位置的动力学

现在我们看一种方案，不需要像前述所说的求解力，而是基于位置的动力学，英文叫 Position Based Dynamics ，简称 PBD。

我们用约束投影代替力和数值积分。如右图，首先我们只检测物体发生穿透碰撞，然后根据约束计算物体的修正位置，最后根据修正位置求解速度。

在这个方案中，如果两个物体发生互相穿透，我们就根据运动方向的反方向直接把物体分开，让它们不穿透，这个过程中，我们不要求解力。这个就是英伟达的 Flex 组件和 Unity 的 Obi 组件的理论基础。

### PBD 算法

接下来，我们看看PBD算法是什么样的。

首先，我们用一个 $N$ 个顶点 和 $M$ 个约束组成的集合表示动力学物体。

1. 第1行，首先对顶点的位置、速度和质量倒数进行初始化。为什么这里是质量倒数？因为后面计算用到的是倒数，这样能避免过多的除法运算，此外，当 $w_i=0$ 可以当成静态物体处理，可以理解为质量无穷大
2. 第3行，我们所有不能转换为位置约束的力，如重力、风力记为 $f_{ext}$ 进行一次数值积分，获得预测速度 $v_i$ 
3. 第4行，通过显示欧拉积分计算位置的预测值 $x_i^*$ 
4. 第5行，生成碰撞约束。物体会与周围环境发生碰撞接触，如布料落在地面上，流水碰上一面墙等等，这些碰撞约束每个时间步长都在发生变化的。但注意，这里并不对约束求解，仅仅是根据发生接触的对象生成约束
5. 第6行，有了这些内部约束（如不可压缩流体的密度约束）和外部约束（如流体不能穿透地板）的数学公式之后，接下来就是对这些约束进行迭代求解，也就是这里的约束投影
6. 第7行，根据约束投影求解得到修正位移，修正前述预测位置以获得较精确的位置
7. 第8行，根据最终位置更新物体速度
8. 第9行，更新物体位置
9. 第10行，根据摩擦系数、恢复系数更新速度

好，这就是 PBD 这个算法的全貌。在看 PBD 算法细节之前，图解几个关键步骤，让大家有更直观的认识

### PBD 算法中位置修正

举个简单粒子，看怎么做位置修正的。首先，一个粒子 $i$ 当前位置为 $\vec{x}_i$ ，经过预测会到 $\vec{x}_i^*$ 位置，然后因为要受到圆的约束，需要在圆上，所以修正位置到  $\vec{x}_i^* + \Delta \vec{p}_i$ ，最后根据 $\vec{x}_i^* + \Delta \vec{p}_i$ 计算当前速度

### PBD 算法中速度修正

速度修正，我们以下这个粒子来说明。首先，一个粒子 $i$ 当前位置为 $\vec{x}_i$ ，经过预测会到 $\vec{x}_i^*$ 位置，然后因为粒子跟另外一个物体发生接触碰撞，受到碰撞约束，所以需要离开被撞物体，防止穿透，所以修正位置到 $\vec{x}_i^* + \Delta \vec{p}_i$ ，最后根据 $\vec{x}_i^* + \Delta \vec{p}_i$ 计算当前速度。然而这里因为发生碰撞，碰撞接触物体后一个受恢复系数(restitution) 影响，一个受摩擦力(friction)影响，所以需要再根据这两个修正当前速度

### 约束

什么是约束？上面在位置修正的时候提到位置要在圆上，这个就是约束，约束在圆上运动。又如上面提到的速度修正中的发生粒子穿透物体，然后让其分离，这个就是碰撞约束。约束通俗点来讲就是字面上的意思，限制行为。

那么我们给准确下个定义就是：在数学中，约束是一个优化问题的解需要符合的条件。符合所有约束的解的集合称为可行集或者候选集。

约束在数学上可以表示成等式约束和不等式约束。如距离约束是等式约束。如接触约束是不等式约束。

约束有多种多样的，用于布料的距离约束；用于刚体、塑料的形状约束；用于流体的密度约束；用于气体的体积约束；用于无穿透的接触约束等

### PBD 的物理意义

接下来看下这个算法的细节，一步步推导怎么求解。先来看看 PBD 的物理意义是什么？PBD 这个方法其实研究的是一个带约束的运动问题。如刚才上面的圆形例子就能比较好说明，被约束在做圆周运动。

根据高斯最小二乘约束原理（Gauss's principle of least constraint），受约束的物体，它的运动轨迹是约束对加速度改变的总和和最小值。这可以表示为：
$$
Z = \text{min} \sum_{i} m_i \parallel \ddot{\vec{p}}_i - \frac{\vec{F}_{ext}}{m_i}\parallel ^2
$$
其中 $\ddot{\vec{p}}$ 头上两个点表示位置 $\vec{p}$ 对时间 $t$ 的二阶导数，所以这里是表示加速度。其中 $\ddot{\vec{p}}_i - \frac{\vec{F}_{ext}}{m_i}$ 的物理意义是：

> 约束对加速度的改变有多大

我们来看一个简单的例子。这个绿色的小球沿着铁环在运动，在运动过程中，它除了受到重力以外，还会受到铁环给它的力，还有摩擦力，空气阻力这样一系列的力。我们可以知道，不管它以什么速度运动，它的运动轨迹肯定是限制在这个圆环上的，像重力这样的外力对小球的加速度的贡献，我们可以很容易的求出来，但是其他的力呢？铁环对它的作用力怎么估计呢？这就有点难办了，所以我们这里通过约束来求其近似值，以把小球约束在圆形轨道上运动，而不去求解力。

### 高斯最小二乘约束原理应用

首先我们把高斯最小二乘约束原理的最小二乘法改一下形式，因为我们不是求最小值，我们是求满足最小值的参数，所以，我们可以写成：
$$
argmin \sum_i m_i \parallel \ddot{\vec{p}} - \frac{\vec{F}_{ext}}{m_i}\parallel^2
$$
然后令 $\vec{p}_i^t$ 和 $\vec{v}_i^t$ 分别表示一个质点 $i$ 在 $t$ 时刻的位置和速度，$\Delta{t}$ 是一个时间步长。那么下一时刻质点 $i$ 的位置为：
$$
\vec{p}_i^{t+\Delta{t}} = \vec{p}_i^t + \Delta{t} (\vec{v}_i^t + \Delta{t} \frac{\vec{F}_{ext}}{m_i}) + \Delta{\vec{p}_i}
$$
其中 $\Delta{\vec{p}_i}$ 就是约束对质点 $i$ 位置的修正。

此时质点 $i$ 的速度为：
$$
\vec{v}_i^{t+\Delta{t}} = \frac{\vec{p}_i^{t+\Delta{t}} - \vec{p}_i^t}{\Delta{t}} = \vec{v}_i^t + \Delta{t} \frac{\vec{f}_{ext}}{m_i} + \frac{\Delta{\vec{p}_i}}{\Delta{t}}
$$
最后，我们可以得到质点 $i$ 的加速度为：
$$
\ddot{\vec{p}_i} = \frac{\vec{v}_i^{t+\Delta{t}} - \vec{v}_i^t}{\Delta{t}} = \frac{\Delta{\vec{p}_i}}{\Delta{t}^2} + \frac{\vec{f}_{ext}}{m_i}
$$
将上面的加速度带入前面最小二乘法中，我们可以得到约束对位置的修正 $\Delta{\vec{p}}$ 
$$
argmin \sum_{i} m_i \parallel \frac{\Delta{\vec{p}}_i}{\Delta{t}^2} \parallel^2
$$
由于我们求的是满足最小值的参数，所以这里的 $\Delta t^2$ 可以直接省略，不影响最小值的结果。即：
$$
argmin \sum_{i} m_i \parallel \Delta{\vec{p}}_i \parallel^2
$$
为了方便展示，我们把该式写成矩阵形式，则可得：
$$
argmin \pmb{\Delta{p}}^T \pmb{M} \pmb{\Delta{p}}
$$
其中 $\pmb{p}$ 、$\Delta \pmb{p}$ 和 $\pmb{M}$ 分别为：
$$
\pmb{p} = 
\begin{bmatrix} \vec{p}_i \\ \vdots \\ \vec{p}_n \end{bmatrix} 
\qquad 
\Delta \pmb{p} = 
\begin{bmatrix} \Delta \vec{p}_1 \\ \vdots \\ \Delta \vec{p}_n
\end{bmatrix}
\qquad
\pmb{M} =
\begin{bmatrix}
m_i & 0 & 0 \\
\vdots & \ddots & \vdots \\
0 & 0 & m_n
\end{bmatrix}
$$
因为我们求的是满足最小值的参数，所以为了后面求导计算方便，再加一个 $\frac{1}{2}$ ，则可得：
$$
argmin \frac{1}{2} \pmb{\Delta{p}}^T \pmb{M} \pmb{\Delta{p}}
$$
最后加个约束，位移要满足约束 $C(\pmb{p})=0$ ，则当加上位移修正值 $\Delta \pmb{p}$ 后，约束 $C(\pmb{p} + \Delta \pmb{p}) = 0$ 依然满足，这就满足高斯最小二乘约束原理

### 单个约束优化求解

我们把前面讨论的高斯最小二乘约束原理写成专业的数学形式：
$$
\begin{array}
\text{argmin} & \frac{1}{2} \pmb{\Delta{p}}^T \pmb{M} \pmb{\Delta{p}} \\
\text{s.t.} & C(\pmb{p} + \pmb{\Delta{p}}) = 0
\end{array}
$$
现在问题就变成一个约束优化的问题。即在满足约束 $C(\pmb{p}+\Delta\pmb{p})=0$ 约束条件下，求 $\frac{1}{2} \pmb{\Delta{p}}^T \pmb{M} \pmb{\Delta{p}}$ 最小值的 $\pmb{\Delta{p}}$ 。那怎么求解呢？这里我们引入拉格朗日乘子法来求解该问题。

我们抽象一下上述的约束优化问题如下：
$$
\begin{array}
\text{argmin} &f(x) \\
\text{s.t.} &g(x) = 0
\end{array}
$$
这里 $f(x)$ 构成一个标量场，这个标量场可以构成许多等值线（2D等高线、3D等高面）。$g(x)$ 是约束函数。

由图可以看到，蓝色线为函数的等值线，整个平面是 $x$ 的空间，但是由于加了约束 $g(x) = 0$ ，所以 $x$ 的可行域就只能是黑色那条线，那条线表示的就是 $g(x)=0$ 。因此找最优解的时候，就只能在黑色线上找。假如没有黑色线的约束，那么函数 $f(x)$ 的极值就应该在最小的蓝色椭圆内（还有没有画出来的更小的椭圆，最终是一个点），蓝色的箭头就表示它们的梯度反方向（函数值减小的方向）。有了黑色线的约束，最优解应该就在蓝色线和黑色线相切的地方，因为相切，所以两条线的梯度反方向应该是方向相同或者相反，也就是梯度是平行的。因此满足方程：
$$
\nabla f(x) + \lambda \nabla g(x) = 0
$$
所以对于等式约束的约束优化问题，当函数的梯度等于等式约束的梯度的线性组合时，可能可以找到最优解。

拉格朗日乘子法的做法就是定义一个新的拉格朗日函数：
$$
L(x, \lambda) = f(x) + \lambda g(x)
$$
对该函数并令其为0，得到的就是上面的方程（有梯度的方程）。这就是等式约束条件的拉格朗日乘子法。拉格朗日法的目的其实就是加多一项控制项，满足条件时，应该帮助最优化的结果；而不满足条件时，就应该破坏最优化的结果。

有了拉格朗日乘子法，我们把
$$
\begin{align}
f(\pmb{p}) &= \frac{1}{2} \pmb{\Delta{p}}^T \pmb{M} \pmb{\Delta{p}} \\
g(\pmb{p}) &= C(\pmb{p})
\end{align}
$$
引入拉格朗日乘子 $\lambda$ ，则：
$$
\nabla f(\Delta \pmb{p}) + \lambda \nabla h(\Delta \pmb{p}) = 0
$$
对 $f(\Delta \pmb{p})$ 和 $h(\Delta \pmb{p})$ 分别求梯度，代入上式，可得：
$$
\pmb{M} \Delta \pmb{p} + \lambda \nabla C(\pmb{p}) = 0
$$
推导着推导着，原来还只有一个未知数 $\Delta \pmb{p}$ ，现在还多了一个未知数 $\lambda$ ，一个方程，两个未知数，怎么解？不用担心，大家别忘了，还有个 $g(x)=0$ 的约束条件，即：
$$
g(\pmb{p})=C(\pmb{p}) = 0
$$
另外由于 $C(\pmb{p})=0$ 和 $C(\pmb{p}+\Delta \pmb{p})=0$ 是同一个约束，是等价的，而现在我们要求的是 $\Delta \pmb{p}$ ，所以我们用 $C(\pmb{p}+\Delta \pmb{p})=0$ 代替 $C(\pmb{p})=0$ 。现在有两个未知数，两个方程，可以解方程组了。联立方程组：
$$
\left\{
\begin{aligned}
& \Delta \pmb{p} = - \lambda \pmb{M}^{-1} \nabla C(\pmb{p}) \\
& C(\pmb{p} + \Delta \pmb{p}) = 0
\end{aligned}
\right.
$$
方程 (2) 是非线性的，我们用泰勒展开，用线性近似，得：
$$
C(\pmb{p} + \Delta \pmb{p}) \approx C(\pmb{p}) + \nabla C(\pmb{p}) \cdot \Delta \pmb{p}
$$
则方程组变成：
$$
\left\{
\begin{aligned}
& \Delta \pmb{p} = - \lambda \pmb{M}^{-1} \nabla C(\pmb{p}) \\
& C(\pmb{p}) + \nabla C(\pmb{p}) \cdot \Delta \pmb{p} = 0
\end{aligned}
\right.
$$


