# 基于物理的流体模拟-PBD部分

## 基于位置动力学（Position Based Dynamics）

### 基于力的动力学

前面介绍了流体力学方面的知识。可以看出传统的物理求解方法，都是基于力来求解的，一般流程是：

1. 计算内力。如流体的粘滞力（Viscosity）、压力（Pressure）等
2. 计算外力。如重力（Gravity）、碰撞力（Collision）、风力（Wind）等
3. 把内力和外力合在一起，根据经典力学牛顿第二定律 $\vec{F}=m\vec{a}$ ，求出加速度
4. 通过数值计算方法，计算速度 $\vec{v}=\vec{a}t$ 
5. 通过数值计算方法，计算位置 $\vec{x}^* = \vec{x}_0 + \vec{v}t$ 

虽然基于上述的计算符合物理规则，但是我们做计算机工程，这种方法在计算机中，特别是实时游戏应用中是否适用呢？我们接下来看看具体情况。

### 基于力的动力学的缺陷

计算物体间的碰撞是物理引擎最核心的部分。如右图，一般来说，先要解决如何高效的检测到碰撞的产生（碰撞检测），以及如何确定碰撞点及方向，之后我们就可以求得碰撞体的受力情况，从而根据牛顿运动定律计算出它们将要产生的平动和转动。最后将场景中物体的位置和姿态输出给图形引擎去渲染。

如何求得力和力矩，这是一个很复杂的问题。

像重力可以直接影响物体所受力，摩擦可以直接影响物体所受力矩，这些都很简单，较为复杂的就是两个物体间的碰撞，物理引擎中有一半以上的代码是用来计算碰撞的。

下面我们来看一个碰撞例子。

由于碰撞时间极短，通常只有千分之一秒甚至万分之一秒，因此所产生的力非常巨大。这种产生在碰撞中，作用时间极短，数值巨大的力称为碰撞力瞬时力。瞬时力的冲量称之为碰撞冲量。瞬时力不仅数值巨大，而且随时间迅速变化，其规律非常复杂，难以确定。碰撞过程中除了由碰撞力引起物体塑性变形外，同时还伴随着发声、发光和发热等机械能转换为其他形式能量的现象。由于碰撞时间很短，发生在瞬时，需要很小的时间步长去计算碰撞力，在实际计算机应用中，特别是实时性要求很强的游戏应用中，如果时间步长分得太多，会有明显的卡顿感，这个严重影响游戏体验。所以我们需要考虑另外的方案来实现游戏中的物理模拟。

### 基于位置的动力学

现在我们看一种方案，不需要像前述所说的求解力，而是基于位置的动力学，英文叫 Position Based Dynamics ，简称 PBD。

我们用约束投影代替力和数值积分。如右图，首先我们只检测物体发生穿透碰撞，然后根据约束计算物体的修正位置，最后根据修正位置求解速度。

在这个方案中，如果两个物体发生互相穿透，我们就根据运动方向的反方向直接把物体分开，让它们不穿透，这个过程中，我们不要求解力。这个就是英伟达的 Flex 组件和 Unity 的 Obi 组件的理论基础。

### PBD 算法

接下来，我们看看PBD算法是什么样的。

首先，我们用一个 $N$ 个顶点 和 $M$ 个约束组成的集合表示动力学物体。

1. 第1行，首先对顶点的位置、速度和质量倒数进行初始化。为什么这里是质量倒数？因为后面计算用到的是倒数，这样能避免过多的除法运算，此外，当 $w_i=0$ 可以当成静态物体处理，可以理解为质量无穷大
2. 第3行，我们所有不能转换为位置约束的力，如重力、风力记为 $f_{ext}$ 进行一次数值积分，获得预测速度 $v_i$ 
3. 第4行，通过显示欧拉积分计算位置的预测值 $x_i^*$ 
4. 第5行，生成碰撞约束。物体会与周围环境发生碰撞接触，如布料落在地面上，流水碰上一面墙等等，这些碰撞约束每个时间步长都在发生变化的。但注意，这里并不对约束求解，仅仅是根据发生接触的对象生成约束
5. 第6行，有了这些内部约束（如不可压缩流体的密度约束）和外部约束（如流体不能穿透地板）的数学公式之后，接下来就是对这些约束进行迭代求解，也就是这里的约束投影
6. 第7行，根据约束投影求解得到修正位移，修正前述预测位置以获得较精确的位置
7. 第8行，根据最终位置更新物体速度
8. 第9行，更新物体位置
9. 第10行，根据摩擦系数、恢复系数更新速度

好，这就是 PBD 这个算法的全貌。在看 PBD 算法细节之前，图解几个关键步骤，让大家有更直观的认识

### PBD 算法中位置修正

举个简单粒子，看怎么做位置修正的。首先，一个粒子 $i$ 当前位置为 $\vec{x}_i$ ，经过预测会到 $\vec{x}_i^*$ 位置，然后因为要受到圆的约束，需要在圆上，所以修正位置到  $\vec{x}_i^* + \Delta \vec{p}_i$ ，最后根据 $\vec{x}_i^* + \Delta \vec{p}_i$ 计算当前速度

### PBD 算法中速度修正

速度修正，我们以下这个粒子来说明。首先，一个粒子 $i$ 当前位置为 $\vec{x}_i$ ，经过预测会到 $\vec{x}_i^*$ 位置，然后因为粒子跟另外一个物体发生接触碰撞，受到碰撞约束，所以需要离开被撞物体，防止穿透，所以修正位置到 $\vec{x}_i^* + \Delta \vec{p}_i$ ，最后根据 $\vec{x}_i^* + \Delta \vec{p}_i$ 计算当前速度。然而这里因为发生碰撞，碰撞接触物体后一个受恢复系数(restitution) 影响，一个受摩擦力(friction)影响，所以需要再根据这两个修正当前速度

### 约束

什么是约束？上面在位置修正的时候提到位置要在圆上，这个就是约束，约束在圆上运动。又如上面提到的速度修正中的发生粒子穿透物体，然后让其分离，这个就是碰撞约束。约束通俗点来讲就是字面上的意思，限制行为。

那么我们给准确下个定义就是：在数学中，约束是一个优化问题的解需要符合的条件。符合所有约束的解的集合称为可行集或者候选集。

约束在数学上可以表示成等式约束和不等式约束。如距离约束是等式约束。如接触约束是不等式约束。

约束有多种多样的，用于布料的距离约束；用于刚体、塑料的形状约束；用于流体的密度约束；用于气体的体积约束；用于无穿透的接触约束等

### PBD 的物理意义

接下来看下这个算法的细节，一步步推导怎么求解。先来看看 PBD 的物理意义是什么？PBD 这个方法其实研究的是一个带约束的运动问题。如刚才上面的圆形例子就能比较好说明，被约束在做圆周运动。

根据高斯最小二乘约束原理（Gauss's principle of least constraint），受约束的物体，它的运动轨迹是约束对加速度改变的总和和最小值。这可以表示为：
$$
Z = \text{min} \sum_{i} m_i \parallel \ddot{\vec{p}}_i - \frac{\vec{F}_{ext}}{m_i}\parallel ^2
$$
其中 $\ddot{\vec{p}}$ 头上两个点表示位置 $\vec{p}$ 对时间 $t$ 的二阶导数，所以这里是表示加速度。其中 $\ddot{\vec{p}}_i - \frac{\vec{F}_{ext}}{m_i}$ 的物理意义是：

> 约束对加速度的改变有多大

我们来看一个简单的例子。这个绿色的小球沿着铁环在运动，在运动过程中，它除了受到重力以外，还会受到铁环给它的力，还有摩擦力，空气阻力这样一系列的力。我们可以知道，不管它以什么速度运动，它的运动轨迹肯定是限制在这个圆环上的，像重力这样的外力对小球的加速度的贡献，我们可以很容易的求出来，但是其他的力呢？铁环对它的作用力怎么估计呢？这就有点难办了，所以我们这里通过约束来求其近似值，以把小球约束在圆形轨道上运动，而不去求解力。

### 高斯最小二乘约束原理应用

首先我们把高斯最小二乘约束原理的最小二乘法改一下形式，因为我们不是求最小值，我们是求满足最小值的参数，所以，我们可以写成：
$$
argmin \sum_i m_i \parallel \ddot{\vec{p}} - \frac{\vec{F}_{ext}}{m_i}\parallel^2
$$
然后令 $\vec{p}_i^t$ 和 $\vec{v}_i^t$ 分别表示一个质点 $i$ 在 $t$ 时刻的位置和速度，$\Delta{t}$ 是一个时间步长。那么下一时刻质点 $i$ 的位置为：
$$
\vec{p}_i^{t+\Delta{t}} = \vec{p}_i^t + \Delta{t} (\vec{v}_i^t + \Delta{t} \frac{\vec{F}_{ext}}{m_i}) + \Delta{\vec{p}_i}
$$
其中 $\Delta{\vec{p}_i}$ 就是约束对质点 $i$ 位置的修正。

此时质点 $i$ 的速度为：
$$
\vec{v}_i^{t+\Delta{t}} = \frac{\vec{p}_i^{t+\Delta{t}} - \vec{p}_i^t}{\Delta{t}} = \vec{v}_i^t + \Delta{t} \frac{\vec{f}_{ext}}{m_i} + \frac{\Delta{\vec{p}_i}}{\Delta{t}}
$$
最后，我们可以得到质点 $i$ 的加速度为：
$$
\ddot{\vec{p}_i} = \frac{\vec{v}_i^{t+\Delta{t}} - \vec{v}_i^t}{\Delta{t}} = \frac{\Delta{\vec{p}_i}}{\Delta{t}^2} + \frac{\vec{f}_{ext}}{m_i}
$$
将上面的加速度带入前面最小二乘法中，我们可以得到约束对位置的修正 $\Delta{\vec{p}}$ 
$$
argmin \sum_{i} m_i \parallel \frac{\Delta{\vec{p}}_i}{\Delta{t}^2} \parallel^2
$$
由于我们求的是满足最小值的参数，所以这里的 $\Delta t^2$ 可以直接省略，不影响最小值的结果。即：
$$
argmin \sum_{i} m_i \parallel \Delta{\vec{p}}_i \parallel^2
$$
为了方便展示，我们把该式写成矩阵形式，则可得：
$$
argmin \pmb{\Delta{p}}^T \pmb{M} \pmb{\Delta{p}}
$$
其中 $\pmb{p}$ 、$\Delta \pmb{p}$ 和 $\pmb{M}$ 分别为：
$$
\pmb{p} = 
\begin{bmatrix} \vec{p}_i \\ \vdots \\ \vec{p}_n \end{bmatrix} 
\qquad 
\Delta \pmb{p} = 
\begin{bmatrix} \Delta \vec{p}_1 \\ \vdots \\ \Delta \vec{p}_n
\end{bmatrix}
\qquad
\pmb{M} =
\begin{bmatrix}
m_i & 0 & 0 \\
\vdots & \ddots & \vdots \\
0 & 0 & m_n
\end{bmatrix}
$$
因为我们求的是满足最小值的参数，所以为了后面求导计算方便，再加一个 $\frac{1}{2}$ ，则可得：
$$
argmin \frac{1}{2} \pmb{\Delta{p}}^T \pmb{M} \pmb{\Delta{p}}
$$
最后加个约束，位移要满足约束 $C(\pmb{p})=0$ ，则当加上位移修正值 $\Delta \pmb{p}$ 后，约束 $C(\pmb{p} + \Delta \pmb{p}) = 0$ 依然满足，这就满足高斯最小二乘约束原理

### 单个约束优化求解

我们把前面讨论的高斯最小二乘约束原理写成专业的数学形式：
$$
\begin{array}
\text{argmin} & \frac{1}{2} \pmb{\Delta{p}}^T \pmb{M} \pmb{\Delta{p}} \\
\text{s.t.} & C(\pmb{p} + \pmb{\Delta{p}}) = 0
\end{array}
$$
现在问题就变成一个约束优化的问题。即在满足约束 $C(\pmb{p}+\Delta\pmb{p})=0$ 约束条件下，求 $\frac{1}{2} \pmb{\Delta{p}}^T \pmb{M} \pmb{\Delta{p}}$ 最小值的 $\pmb{\Delta{p}}$ 。那怎么求解呢？这里我们引入拉格朗日乘子法来求解该问题。

我们抽象一下上述的约束优化问题如下：
$$
\begin{array}
\text{argmin} &f(x) \\
\text{s.t.} &g(x) = 0
\end{array}
$$
这里 $f(x)$ 构成一个标量场，这个标量场可以构成许多等值线（2D等高线、3D等高面）。$g(x)$ 是约束函数。

由图可以看到，蓝色线为函数的等值线，整个平面是 $x$ 的空间，但是由于加了约束 $g(x) = 0$ ，所以 $x$ 的可行域就只能是黑色那条线，那条线表示的就是 $g(x)=0$ 。因此找最优解的时候，就只能在黑色线上找。假如没有黑色线的约束，那么函数 $f(x)$ 的极值就应该在最小的蓝色椭圆内（还有没有画出来的更小的椭圆，最终是一个点），蓝色的箭头就表示它们的梯度反方向（函数值减小的方向）。有了黑色线的约束，最优解应该就在蓝色线和黑色线相切的地方，因为相切，所以两条线的梯度反方向应该是方向相同或者相反，也就是梯度是平行的。因此满足方程：
$$
\nabla f(x) + \lambda \nabla g(x) = 0
$$
所以对于等式约束的约束优化问题，当函数的梯度等于等式约束的梯度的线性组合时，可能可以找到最优解。

拉格朗日乘子法的做法就是定义一个新的拉格朗日函数：
$$
L(x, \lambda) = f(x) + \lambda g(x)
$$
对该函数并令其为0，得到的就是上面的方程（有梯度的方程）。这就是等式约束条件的拉格朗日乘子法。拉格朗日法的目的其实就是加多一项控制项，满足条件时，应该帮助最优化的结果；而不满足条件时，就应该破坏最优化的结果。

有了拉格朗日乘子法，我们把
$$
\begin{align}
f(\pmb{p}) &= \frac{1}{2} \pmb{\Delta{p}}^T \pmb{M} \pmb{\Delta{p}} \\
g(\pmb{p}) &= C(\pmb{p})
\end{align}
$$
引入拉格朗日乘子 $\lambda$ ，则：
$$
\nabla f(\Delta \pmb{p}) + \lambda \nabla h(\Delta \pmb{p}) = 0
$$
对 $f(\Delta \pmb{p})$ 和 $h(\Delta \pmb{p})$ 分别求梯度，代入上式，可得：
$$
\pmb{M} \Delta \pmb{p} + \lambda \nabla C(\pmb{p}) = 0
$$
推导着推导着，原来还只有一个未知数 $\Delta \pmb{p}$ ，现在还多了一个未知数 $\lambda$ ，一个方程，两个未知数，怎么解？不用担心，大家别忘了，还有个 $g(x)=0$ 的约束条件，即：
$$
g(\pmb{p})=C(\pmb{p}) = 0
$$
另外由于 $C(\pmb{p})=0$ 和 $C(\pmb{p}+\Delta \pmb{p})=0$ 是同一个约束，是等价的，而现在我们要求的是 $\Delta \pmb{p}$ ，所以我们用 $C(\pmb{p}+\Delta \pmb{p})=0$ 代替 $C(\pmb{p})=0$ 。现在有两个未知数，两个方程，可以解方程组了。联立方程组：
$$
\left\{
\begin{aligned}
& \Delta \pmb{p} = - \lambda \pmb{M}^{-1} \nabla C(\pmb{p}) \\
& C(\pmb{p} + \Delta \pmb{p}) = 0
\end{aligned}
\right.
$$
方程 (2) 是非线性的，我们用泰勒展开，用线性近似，得：
$$
C(\pmb{p} + \Delta \pmb{p}) \approx C(\pmb{p}) + \nabla C(\pmb{p}) \cdot \Delta \pmb{p}
$$
则方程组变成：
$$
\left\{
\begin{aligned}
& \Delta \pmb{p} = - \lambda \pmb{M}^{-1} \nabla C(\pmb{p}) \\
& C(\pmb{p}) + \nabla C(\pmb{p}) \cdot \Delta \pmb{p} = 0
\end{aligned}
\right.
$$
最后解得：
$$
\left\{
\begin{aligned}
& \lambda = \frac{C(\pmb{p})}{\nabla C(\pmb{p})^T M^{-1} \nabla C(\pmb{p})} \\
& \Delta \pmb{p} = - \lambda M^{-1} \nabla C(\pmb{p})
\end{aligned}
\right.
$$
自此，我们求出了单个约束的解。然而，实际情况是，我们一个点会受很多条件约束，也就是存在多约束的情况。接下来，我们看看多个约束优化如何求解

### 多个约束优化求解

前面讨论的都是 N 个粒子受 1 个约束的情况：
$$
\Delta \pmb{p} = -\lambda \pmb{M}^{-1} \nabla C(\pmb{p})
$$
这里
$$
\Delta \pmb{p} = \begin{bmatrix} \Delta \vec{p}_1 \\ \vdots \\ \Delta \vec{p}_n\end{bmatrix}
$$
这是受一个约束的情况。那么多个约束是怎样的？N 个粒子受 M 个约束的情况：
$$
\begin{aligned}
\pmb{\Delta p_1} &= -\lambda_1 \pmb{M}^{-1} \nabla C_1(\pmb{p}) \\
\pmb{\Delta p_2} &= -\lambda_2 \pmb{M}^{-1} \nabla C_2(\pmb{p}) \\
\qquad \qquad \vdots \\
\pmb{\Delta p_M} &= -\lambda_M \pmb{M}^{-1} \nabla C_M(\pmb{p}) \\
\end{aligned}
$$
可以看出，这里是由 M 个约束构成的一个方程组。而在物理模拟中约束的个数，梯度的维数都无法保证，彼此间是否线性相关也无法保证，所以这个方程组可能有唯一解，也可能没有解，也可能有无限多个解。如图所示，三个等式约束，但是无法同时满足这三个约束，所以是无解的。那是不是就无法去求解呢？在 PBD 中，直接忽略这种有无解的情况，换了另外的方式去求解。我们看下 PBD 可以用什么方法求解，并且相关的方法会带来什么问题。一般我们都用迭代法来代替直接求解，迭代求解一般有以下两种：

1. 高斯-赛德尔迭代法
2. 雅可比迭代法

### 约束求解器

我们先看一下高斯-赛德尔（Gauss-Seidel）迭代是怎么求解的。如图所示，使用高斯-赛德尔方法求解，第一步先代入 约束 $C_1$ ，解会在 $C_1$ 的解空间中，然后把解代入约束 $C_2$ ，解会在约束 $C_2$ 的解空间中。也就是说用高斯-赛德尔方法解会在解空间之间来回跳跃，然后慢慢靠近共同的解空间。整体来讲，高斯-赛德尔迭代收敛速度较慢，并且由于每一个约束方程求解都需要用上一个约束方程的解作为当前约束方程的输入，所以导致无法并行。

然后我们看看雅可比迭代是怎么求解的。如图所示，雅可比迭代先求解关于约束 $C_1$ 的方程，计算出到 $C_1$ 解空间的向量。然后求解关于约束 $C_2$ 的方程到 $C_2$ 解空间的向量。然后向着两个向量的合向量前进，寻找关于 $C_1$ 、$C_2$ 的相交解空间。这样的话如果 $C_1$ 和 C_2$ 的解空间在同一个方向，雅可比迭代使用合向量作为步长，经常会一步迈过，下一步再买回起始点，导致不能收敛。但是当解空间不同向的时候，雅可比迭代法由于向着合向量迭代，不会像高斯-赛德尔方法那样在两个解空间之间来回跳跃，反而稳定性较好。

从这里我们可以看到雅可比迭代收敛速度慢甚至可能无法收敛，但是因为其解之间并无依赖，所以利于并行。

PBD 选择用哪一种迭代方式呢？由于雅可比迭代可以并行，在计算机中更方便使用。另外为了解决上面提到的一步迈过不能收敛的问题，有人提出使用平均雅可比迭代法，就是把合向量接起来，然后除以向量个数。 PBD 也是采用了这种方式。另外为了加速收敛，PBD 还加上了超松弛因子 $\omega$ 。

### 约束求解优先级

在实践中，不同约束类型之间的处理是有优先级的，为了实现这个，我们按照约束类型分组，相同约束类型的分成一组。然后优先级高的约束分组先处理，先求出 $\Delta \vec{p}_i$ 并把该值累加到原位移 $\vec{p}_i$ 上，然后再处理其他优先级较低的约束分组。例如，先处理碰撞约束，让粒子跟物体不发生接触，把该分离后的位置应用到原位移上，得出新位置 $\vec{p}_i^*$ ，然后再处理流体密度约束。这种方式能加快约束修正位置的收敛速度，能够快速接近真实解。

前面讲了一大堆，这就是 PBD 算法的全貌和细节。当然，具体的约束根据物体形态不一样，应用不一样的约束条件。接下来我们看看流体相关的约束及其处理。

## 基于位置流体模拟（Position Based Fluid）

前面讲了 PBD 算法的原理和整个过程的推导。那么我们基于 PBD 的流体是怎么实现的呢？下面我们来讨论下基于位置的流体模拟 —— PBF。

### 流体的密度约束

在不可压缩流体模拟中，我们希望粒子 $i$ 的密度尽量与静止密度 $\rho_0$ 相同，即 $\rho_i = \rho_0$ 。因此需要针对每一个流体粒子都施加一个常量密度约束，PBF 将该约束定义为：
$$
C_i(\vec{p}_1, \cdots, \vec{p}_n) = \frac{\rho_i}{\rho_0} - 1
$$
从这里可以看到，我们要求密度约束，我们已经知道静止密度 $\rho_0$ ，所以剩下就是求粒子 $i$ 的密度 $\rho_i$ 。前面在 SPH 那一节我们提到如何求空间位置 $\vec{x}_i$  一个物理量：
$$
A_i = \sum_j \frac{m_j}{\rho_j} A_j W(\vec{x}_i - \vec{x}_j, h)
$$
我们在回顾下这个公式，其中 $j$ 表示所有邻居粒子，W 是核函数，就是求权重的，h 是核半径，$\vec{x}_i - \vec{x}_j$ 就是两个粒子之间的距离了。

好，有了这个公式之后，既然 $A_i$ 是物理量，那么密度也是一种物理量，所以可以把密度直接代入该公式，可以得出粒子 $i$ 的密度是：
$$
\rho_i = \sum_j m_j W(\vec{x}_i - \vec{x}_j, h)
$$
由于流体每个粒子质量相等，所以在这里我们可以省去质量 $m_j$ ，按照前述 PBD 的算法，需要用到约束 $C_i$ 的梯度，这里梯度是：
$$
\nabla_{\vec{x}_k} C_i = \frac{1}{\rho_0} \sum_j \nabla_{\vec{x}_k} W(\vec{x}_i - \vec{x}_j, h)
$$
这里看起来也比较简单，但是大家注意到没有，这里的下标变成 $\vec{x}_k$ ，多了个 $k$ ，这表明不仅仅是邻居粒子 $j$ 这么简单了。所以这里又有两种情况：粒子 $k$ 为粒子 $i$ 自身（$k=i$）或粒子 $i$ 的邻居粒子 $j$ （$k=j$），即：
$$
\nabla_{\vec{x}_k} = \frac{1}{\rho_0}
\begin{cases}
\sum_j \nabla_{\vec{x}_k} W(\vec{p}_i - \vec{x}_j, h) \quad &k = i \\
- \nabla_{\vec{x}_k} W(\vec{x}_i - \vec{x}_j, h) \quad &k = j
\end{cases}
$$
我们可以这么理解：

1. 当 $k=i$ 时，$\nabla_{\vec{x}_k} C_i = \nabla_{\vec{x}_i}C_i$ 表示约束函数 $C_i$ 关于 $\vec{x}_i$ 的梯度，方向为 $\frac{\vec{x}_i-\vec{x}_j}{\parallel \vec{x}_i - \vec{x}_j\parallel} $ 
2. 当 $k=j$ 时，$\nabla_{\vec{x}_k} C_i = \nabla_{\vec{x}_j}C_i$ 表示约束函数 $C_i$ 关于 $\vec{x}_j$ 的梯度，方向为 $-\frac{\vec{x}_i-\vec{x}_j}{\parallel \vec{x}_i - \vec{x}_j\parallel}$

不知道大家注意到没有，求密度的时候，是用附近邻居的密度按照权重来计算自己的密度，求密度的时候求和是没有自己的。但是这里求梯度，却要分自己和邻居，为什么会这样子呢？其实按照前述SPH的算法，是整个场的所有粒子都考虑进去的，只是因为邻居以外的粒子权重为0 ，所以相邻范围外的粒子的梯度就不要参与计算，但是范围里的所有粒子都参与计算，所以这里要考虑上自己的梯度值。又由于自己的梯度值无法直接得出，所以用附近邻居的粒子的梯度值加权近似求得。

最后按照前述的PBD方法需要求拉格朗日乘子：
$$
\lambda = - \frac{C(\pmb{p})}{\nabla C(\pmb{p})^T \nabla C(\pmb{p})} =- \frac{C(\pmb{p})}{\parallel \nabla C(\pmb{p})\parallel^2}
$$
把其展开，即：
$$
\lambda_i = - \frac{C_i(\vec{p}_i, \cdots, \vec{p}_n)}{\sum_k \parallel \nabla_{\vec{p}_k} C_i\parallel^2}
$$
这个拉格朗日乘子 $\lambda_i$ 对于一个约束 $C_i(\vec{x}_i, \cdots, \vec{x}_n)$ 中所有的粒子而言都是一样的。

还有一个问题，这个W权重函数，就是前面SPH提到的核函数。

### 拉格朗日乘子中的除0

如果一个约束条件不能被违反，则称为硬约束；反之，能够一定程度上被违反的约束为软约束。理想情况下，我们当然希望约束始终都是硬约束，但是由于计算误差或者数值稳定性等原因，我们有时也需要约束呈现出软性质。

在 PBF 中，当 $\parallel \vec{r} \parallel = h$ 时，即邻居粒子 $j$  处于粒子 $i$ 的光滑核半径 $h$ 边缘时（此时粒子 $i$ 和粒子 $j$ 处于分离状态），则前述的 Spiky 核函数梯度值 $\nabla W(\vec{r}, h) = 0$ 。如果粒子之间都处于这种状态，由前述的PBF梯度公式可知：
$$
\begin{aligned}
& \nabla_{\vec{x}_j}C_i = - \frac{1}{\rho_0} \nabla_{\vec{x}_j}W(\vec{r}, h) = 0 \\
& \nabla_{\vec{x}_i}C_i = \frac{1}{\rho_0} \sum_j \nabla_{\vec{x}_i}W(\vec{r}, h) = 0
\end{aligned}
$$
从而前述拉格朗日乘子的分母 $\sum_k \parallel \nabla_{\vec{p}_k} C_i \parallel^2 = 0$ ，这会导致除零错误。为了解决这个问题，PBF 借鉴了 Open Dynamics Engine 中混合约束力方法，使密度约束变成软约束。具体做法就是直接加入一个松弛参数 $\epsilon$ ，这个由用户直接指定。则拉格朗日乘子变成：
$$
\lambda_i = - \frac{C_i(\vec{p}_i, \cdots, \vec{p}_n)}{\sum_k \parallel \nabla_{\vec{p}_k} C_i\parallel^2 + \epsilon}
$$
经过上述一轮推导，最终的粒子 $i$ 的修正位移为：
$$
\begin{aligned}
\Delta \vec{x}_i &= \lambda_i \nabla_{\vec{x}_i} C_i + \sum_j \lambda_j \nabla_{\vec{x}_j} C_i \\
&= \frac{1}{\rho_0} \sum_j \lambda_i \nabla_{\vec{x}_i} W(\vec{r}, h) + (-\frac{1}{\rho_0} \sum_j \lambda_j \nabla_{\vec{x}_j} W(\vec{r}, h)) \\
&= \frac{1}{\rho_0} \sum_j \lambda_i \nabla_{\vec{x}_i} W(\vec{r}, h) + \frac{1}{\rho_0} \sum_j \lambda_j \nabla_{\vec{x}_i} W(\vec{r}, h) \\
&= \frac{1}{\rho_0} \sum_j （\lambda_i + \lambda_j）\nabla_{\vec{x}_i} W(\vec{r}, h) 
\end{aligned}
$$
这里等式第二步推导中，负号怎么变正号了？大家回忆上前述提到的：

1. 当 $k=i$ 时，$\nabla_{\vec{x}_k} C_i = \nabla_{\vec{x}_i}C_i$ 表示约束函数 $C_i$ 关于 $\vec{x}_i$ 的梯度，方向为 $\frac{\vec{x}_i-\vec{x}_j}{\parallel \vec{x}_i - \vec{x}_j\parallel} $ 
2. 当 $k=j$ 时，$\nabla_{\vec{x}_k} C_i = \nabla_{\vec{x}_j}C_i$ 表示约束函数 $C_i$ 关于 $\vec{x}_j$ 的梯度，方向为 $-\frac{\vec{x}_i-\vec{x}_j}{\parallel \vec{x}_i - \vec{x}_j\parallel}$

所以这里 $\nabla_{\vec{x}_j}C_i$ 方向上是跟 $\nabla_{\vec{x}_i}C_i$ 相反的，所以这里负号变成正号，约束函数 $C_i$ 关于 $\vec{x}_j$ 的梯度就变成约束函数 $C_i$ 关于 $\vec{x}_i$ 的梯度。

自此，PBF求解部分已经完成了。最后还有个技巧避免一些鬼畜的问题。下面介绍下。

### Tensile Instability

对于采用SPH插值技术计算密度的流体模拟方法，通常需要30∼40个邻居粒子才能使密度求值结果趋于静态密度。在邻居粒子不足的情况下，会导致求出的流体密度低于静态密度，由此造成压强为负数，原本粒子间的压力变为吸引力，使粒子产生不符合实际情况的凝聚，此即 SPH 的 Tensile Instability 问题在流体模拟中的具体体现，这导致的结果是流体表面的模拟给人感觉不真实。

一种解决方法是采用了一种人工排斥力计算模型，当流体粒子距离过近时该排斥力会使它们分开，从而避免粒子凝聚现象。当流体粒子的压强变为负数时，用该排斥力代替压力可以有效消除SPH方法的Tensile Instability问题，防止负压强导致的粒子间非自然吸引。

另一种解决方法，前述我们讲约束的时候提到约束有两种：

1. 等式约束：总是进行投影操作。
2. 不等式约束 ：只有在不等式约束条件不满足，即 $C_i(\vec{x}_1, \cdots, \vec{x}_n)<0$ 时才进行约束投影操作。

所以，只有在上面的单边约束条件不满足，即 $\frac{ρ_i}{ρ_0} -1>0$ 或 $ρ_i>ρ_0$ 时，才进行约束投影操作。直观理解就是只有在粒子靠的比较近（流体压缩了）的情况下，才需要进行操作让粒子分开（保持流体不可压缩）。而当 $\frac{ρ_i}{ρ_0} -1≤0$ 或 $ρ_i≤ρ_0$ 不等式约束条件满足，此时不需要进行约束投影，因此也就避免了表面粒子凝聚问题。

## 后续

好，讲了那么多，今天的介绍也差不多到这里为止了。实际上在这个领域还有很多事情可以做的。

 PBD 能做很多事情，例如把整个物理世界用粒子来模拟，那么可以把刚体、软体、沙粒、布料、流体等统一起来，实现各种不同材料物体之间的交互。这就是 Unified particle physics (UPP)

另外上面介绍了欧拉、拉格朗日法，实际上还有一些情况是 混合欧拉-拉格朗日法（Hybrid）

还有个各种约束在这里也没有详细介绍了，后面有机会再给大家进行深入介绍各种约束，可以实现前面提到的 UPP 系统。

并行计算，这个跟计算机落地实现有关，真是的模拟上在 PC、主机等 GPU 强悍的硬件环境中，是比较容易做到的，但是在终端等 GPU 计算能力比较弱的设备上，还需要进一步研究探索并行化。当然，obi 依赖 burst compiler 做到了终端上有限粒子的物理模拟。

还有流体力学中的涡流、湍流等，在实时模拟中也是计算量比较大的，也是比较难以实现的。这方面也可以进一步探索。

最后还有这里提到的都是物理模拟，那么最终在计算机中还要呈现出来给用户才能是真的模拟，所以还有流体渲染，也是一个技术方向。

当然，还有流体模拟上，还有很多很多的事情可以去探索可以去做的。

